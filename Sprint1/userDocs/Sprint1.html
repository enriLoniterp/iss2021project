<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
	font-size: 93%;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
	border-radius: 10px;
	padding: 5px;
}

top {
	width: 100%;
}


#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 90%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #abe876;
    color: #1632cc;
}
bc{
	font-family: "Arial";
	font-size: 90%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;
	font-size: 90%;
}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;
	font-size: 90%;
}
kr{
	font-family: "Arial";
	font-weight: bold;
    color: #ff0000	;
	font-size: 90%;
}
pre{
	font-family: "Consolas";
	font-size: 85%;
	background-color: #f5f5f5;
	border: 1.5px solid silver;
	padding: 5px;
}
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{

    font-size: 18px;
}
k{
    color: #990000;
	font-weight: bold;
	font-size: 90%;
}
h1 {
    font-size: 150%;
    background-color: #b2c0ff;
	padding: 10px;
}

h2 {
    background-color: #9ed8ff;
    font-size: 130%;
}

h3 {
	background-color: #e6ccff;
    font-size: 100%;
}
h4 {
    background-color: #ccffcc;
    font-size: 100%;
	width: 95%;
	border-radius: 5px;
	padding: 2px;
}
h5 {
    background-color: #d5ffb0;
    font-size: 100%;

}
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}
div.remark{
	background-color: #E3F2FD;
    border: 1.5px solid #d5f2ed;
    padding: 15px;
    margin: 10px;
	border-radius: 25px;
}
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}

#exampleclass tbody,
#exampleclass thead,
#exampleclass th {
  border: 0;
}

ol, ul, li {
  margin: 0;
  margin-left: 10px;
  padding: 0;
  padding-bottom: 5px;
}

table, th, td {
	border: 1px solid black;
}

img {
	border: 1.5px solid #d5f2ed

}

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

div.wrapdesc{
	width: 90%;
	margin: auto;
}

div.imagedesc{
	width: 85%;
	margin: auto;
}
</style>

<head>

<title>Final task ISS-2021 Bologna: Automated Car-Parking - Sprint 1</title></head>

<body>
<div id="top">
<h1>Final task ISS-2021 Bologna: Automated Car-Parking - Sprint 1<font size="5"></font> </h1>
</div>

<div class="body">
<div id = "backlog">
  <h2>Sprint 1 Backlog</h2>
  <div class="remark">
    Sprint 1 regards the develop of the <ks>PMS</ks> basic functionalities - sensors:
    <ul>
      <li><ks>PMS</ks> manages data from sensors: <a href="http://htmlpreview.github.io/?https://github.com/enriLoniterp/iss2021project/blob/main/requirements/userDocs/Automated%20Car-Parking.html#R1" target = "_blank">R1</a>,
        <a href="http://htmlpreview.github.io/?https://github.com/enriLoniterp/iss2021project/blob/main/requirements/userDocs/Automated%20Car-Parking.html#R3" target = "_blank">R3</a>;</li>
    </ul>
  </div>
</div>
<h4>Starting point</h4>
<center><img src="IMG/StartingPoint.png" alt="starting_point_sprint1" width="30%"></center>


<div id = "problem_analysis">
<h2>Problem analysis</h2>
<div class="remark">
  This Sprint aim is to develop and deeper describe the following entities:
  <ul>
    <li><ks>PMS</ks>;</li>
    <li><ks>Outsonar</ks>;</li>
    <li><ks>Weightsensor</ks>;</li>
    <li><ks>Thermometer</ks>.</li>
  </ul>
</div>
<div class = "remark">
  An initial model of these entities, without interaction between them, can be found <a href = "https://github.com/enriLoniterp/iss2021project/blob/main/Sprint1/model1/src/model1.qak" target = "_blank">here</a>.<br>
</div>
<div id = "problem_analysis_PMS">
  <h3>PMS</h3>
  <div class = "remark">
    From the <a href="#backlog">backlog</a>, the <ks>Park Manager Service</ks> needs to manage data from the <ks>outsonar</ks>, the <ks>weightsensor</ks> and the <ks>thermometer</ks>. <br>
    In anticipation of the next Sprints, given that the <ks>PMS</ks> must interact with different components using specific interaction methods for each case,
    a monolithic <ks>PMS</ks> <u>should be avoided</u>.
  </div>
  <h4>Communication</h4>
  <div class = "remark">
    Starting from what was said in the <a href="http://htmlpreview.github.io/?https://github.com/enriLoniterp/iss2021project/blob/main/requirements/userDocs/Automated%20Car-Parking.html" target = "_blank">first analysis</a>, the <ks>PMS</ks> interacts with the sensors through <b>events</b>. <br>
    This interaction can take place through many protocols, including:
    <ul>
      <li><a href="https://en.wikipedia.org/wiki/MQTT" target = "_blank">                             <b>MQTT</b></a>;</li>
      <li><a href="https://en.wikipedia.org/wiki/Constrained_Application_Protocol" target = "_blank"> <b>CoAp</b></a>;</li>
      <li><a href="https://en.wikipedia.org/wiki/WebSocket" target = "_blank">                        <b>WebSocket</b></a>;</li>
    </ul>
  </div>
</div>
<h3>Outsonar</h3>
<div class = "remark">
  <ks>Outsonar</ks> data can be:
  <ul>
    <li>Generated using a proper utility like <a href="https://github.com/anatali/issLab2021/blob/main/it.unibo.rasp2021/codedqak/sonarSimulator.kt" target = "_blank">sonarSimulator.kt</a>
      or <a href="https://github.com/anatali/issLab2021/blob/main/it.unibo.qakradar21/resources/coap/sonarDataSimulatorCoap.kt" target = "_blank">sonarDataSimulatorCoap.kt</a> given by the client;</li>
    <li>Produced by a real sonar device placed in the outdoor area. In that case <a href="https://github.com/anatali/issLab2021/blob/main/it.unibo.rasp2021/resources/rasp/sonar/SonarAlone.c" target = "_blank">SonarAlone.c</a> allows to read the data from the sonar and write it on the standard output.
      In addiction, data can be managed using the code given by the customer <a href="https://github.com/anatali/issLab2021/tree/main/it.unibo.rasp2021" target = "_blank">rasp2021</a></li>
  </ul>
</div>
</div>
The sprint 1 should be done in <b>three days</b>.
<div id = "project">
<h2>Project</h2>
Starting from the <a href="http://htmlpreview.github.io/?https://github.com/enriLoniterp/iss2021project/blob/main/requirements/userDocs/Automated%20Car-Parking.html#architectural_model" target = "_blank">logical architecture</a>
and from the <a href="#backlog">product backlog</a> we can now "zoom in" and design the entities pointed out in the analysis.<br>
To better manage complexity, it is advisable to adopt a “divide et impera” approach and follow the principle of single responsibility, thus making the system less fragile and more easily modifiable.
About the general architecture of the system, from now on we will develop an <a href="https://en.wikipedia.org/wiki/Hexagonal_architecture_(software)" target = "_blank">hexagonal architecture</a>
which allows to create an abstraction layer that protects the core of the application and isolates it from external tools and technologies.
For this purpose, ports and adapters are used to interact with external entities and allow to design all our system’s interfaces ‘by purpose’ rather than by
technology, preventing lock-in, and making easier for our application’s tech stack to evolve with time.
<h4>Specifications common to all sensors</h4>
<table cellpadding="5%">
  <tr>
    <td width = "50%">
        In order to make the application more modular and easier to modify, we decided to use a <b>single interface</b>
        (<a href="https://github.com/enriLoniterp/iss2021project/blob/main/Sprint1/sensors/src/main/kotlin/SensorPort.kt" target = "_blank">SensorPort.kt</a>)
        for all adapters and a <b>Factory class</b> (<a href="https://github.com/enriLoniterp/iss2021project/blob/main/Sprint1/sensors/src/main/kotlin/SensorFactory.kt" target = "_blank">SensorFactory.kt</a>)
        to allow the business logic to obtain the right instance of the adapter for a given type of sensor (<a href="https://github.com/enriLoniterp/iss2021project/blob/main/Sprint1/sensors/src/main/kotlin/SensorType.kt" target = "_blank">SensorType.kt</a>).
        We decided to use <b>MQTT protocol</b> to receive sensors events through a broker because it fits well for IoT application and perform better as a bus for live data than CoAp and websocket protocols.
      <a href="https://mosquitto.org/" target = "_blank"><b>Mosquitto</b></a> / <a href="https://www.hivemq.com/" target = "_blank"><b>HiveMQ</a></b> is used as a broker and <a href="https://www.eclipse.org/paho/index.php?page=clients/python/index.php" target = "_blank"><b>paho</b></a> library is used to implement the communication.
    </td>
    <td>
      <center>
        <img src="IMG/specification.jpg" alt="specifications_common_to_all_sensors" width="100%">
      </center>
    </td>
  </tr>
</table>
<h3>Outsonar</h3>
<div class="remark">
  The outsonar have to be a physical sensor attached to a <b>Raspberry Pi</b>.
  For the sake of simplify the developed and because a real outsonar can generate spurios data, we decided to use the code in
  <a href="https://github.com/anatali/issLab2021/tree/main/it.unibo.rasp2021" target = "_blank">rasp2021</a> as a staring point..<br>
  The image below shows the model used in our application.
  <center><img src="IMG/sonar_pipe.jpg" alt="sonar_pipe" width="60%"></center>
  Last <a href="https://github.com/enriLoniterp/iss2021project/blob/main/Sprint1/outsonar/src/it/unibo/sonar/Sonar.kt" target = "_blank">actor</a> in the pipe
  has been modified in order to emit events only if the new distance measured is different from the previously one. This feature allows the <ks>PMS</ks> to handle
  less information.
  In addiction, data from the sonar can be simulated using <a href="https://github.com/anatali/issLab2021/blob/main/it.unibo.rasp2021/codedqak/sonarSimulator.kt" target = "_blank">sonarSimulator.kt</a>.
  The <a href="https://github.com/enriLoniterp/iss2021project/blob/main/Sprint1/outsonar/sonar2021ConfigKb.pl" target = "_blank">configuration file</a> allows to choose beetween the real and the simulated sonar.
</div>
<h4>PMS interaction with outsonar</h4>
<div class="remark">
  <table>
    <tr>
      <td width="50%">
        With regard to <ks>outsonar</ks>, the adapter(<a href="https://github.com/enriLoniterp/iss2021project/blob/main/Sprint1/sensors/src/main/kotlin/outsonar/OutSonarAdapter.kt" target = "_blank">OutSonarAdapter.kt</a>)
        maintains the last value generated by the outsonar and implements the method <i>getValue()</i>
        of the interface, which allows the rest of the application to know the actual value of this sensor.
        The callback class(<a href="https://github.com/enriLoniterp/iss2021project/blob/main/Sprint1/sensors/src/main/kotlin/outsonar/OutSonarCallback.kt" target = "_blank">OutSonarCallback.kt</a>)
        receives the message, processes them using the <a href = "https://github.com/anatali/issLab2021/blob/main/it.unibo.qakactor/src/main/kotlin/ApplMessage.kt" target = "_blank">ApplMessage.kt</a>
        and updates the adapter state variable.
      </td>
      <td>
        <center>
          <img src="IMG/outsonar.jpg" alt="outsonar" width="80%">
        </center>
      </td>
    </tr>
  </table>
</div>
<h3>Weightsensor</h3>
<div class="remark">
  <table>
    <tr>
      <td width="50%">
        Since there aren't particular requirements for the weightsensor, it has been developed as a mock object <a href="https://github.com/enriLoniterp/iss2021project/blob/main/Sprint1/sensors/src/main/kotlin/weightsensor/WeightSensorMockMQTT.ipynb" target = "_blank">WeightSensorMock</a>
        that periodically emits events.
        The data sent by the mock can be generated by manually input new values or randomly.
        As previously described, the component integration strategy uses MQTT protocol and paho as a client. <br>
        Due to same kind of interaction as the outsonar, we can basically use the same classes used with the oursonar and refactor variables and the data we need for this sensor.
        For that reason the <a href="https://github.com/enriLoniterp/iss2021project/blob/main/Sprint1/sensors/src/main/kotlin/weightsensor/WeightSensorAdapter.kt" target = "_blank">WeightSensorAdapter.kt</a> and the
        <a href="https://github.com/enriLoniterp/iss2021project/blob/main/Sprint1/sensors/src/main/kotlin/weightsensor/WeightSensorCallback.kt" target = "_blank">WeightSensorCallback.kt</a> works as their outsonar counterparts.
      </td>
      <td>
        <center>
          <img src="IMG/weightsensor.png" alt="weightsenor" width="80%">
        </center>
      </td>
    </tr>
  </table>
</div>
<h3>Thermometer</h3>
<div class="remark">
  <table>
    <tr>
      <td width="50%">
        As for the weightsensor, the thermometer has been developed as a mock object <a href="https://github.com/enriLoniterp/iss2021project/blob/main/Sprint1/sensors/src/main/kotlin/thermometer/ThermometerMockMQTT.ipynb" target = "_blank">ThermometerMock</a> that periodically emits events. It works like the
        WeightSensorMock but the value randomly generated range from -10 to 50 degrees.<br>
        Again, due to the same type of interaction,  we developed <a href="https://github.com/enriLoniterp/iss2021project/blob/main/Sprint1/sensors/src/main/kotlin/thermometer/ThermometerAdapter.kt" target = "_blank">ThermometerSensorAdapter.kt</a>
        and <a href="https://github.com/enriLoniterp/iss2021project/blob/main/Sprint1/sensors/src/main/kotlin/thermometer/ThermometerCallback.kt" target = "_blank">ThermometerCallback.kt</a> reusing the code previously
        detailed.
      </td>
      <td>
        <center>
          <img src="IMG/thermometer.png" alt="thermometer" width="80%">
        </center>
      </td>
    </tr>
</table>
</div>
</div>


<h2>Testing</h2>
<div class="remark">
  To carry out the test plan, three <b>Unit Test</b> have been developed, one for each adapter (<a href="https://github.com/enriLoniterp/iss2021project/blob/main/Sprint1/sensors/src/test/kotlin/SensorsTest.kt" target = "_blank">SensorsTest.kt</a>).
  Testing has been made using JUnit through IntelliJ IDE.
  All tests share the same logic which check if received values are correct. Test behaviour is the following:
  <pre>
    <b>X</b> as <ks>outsonar</ks> / <ks>weightsensor</ks> / <ks>thermometer</ks>
    creation of an istance of <ks>adapter</ks> <b>X</b>
    creation of a <ks>MQTT client</ks>
    client connects to the <ks>broker</ks>
    creation of the message event through <em>MsgUtils</em>
    event emitted to <b>X</b> adapter <ks>topic</ks>
    check if <b>adapter internal status == value sent</b>
  </pre>


</div>

<h4>Summary point</h4>
<center><img src="IMG/esagono.jpg" alt="summary_point" width="50%"></center>
<h2>Deployment</h2>
<div class="remark">
  In this Sprint we decided to deploy the driven side which includes outsonar, thermometer and weightsensor,
  while ports and adapters will be deployed in future Sprints. <br>
  <a href ="https://github.com/enriLoniterp/iss2021project/blob/main/Sprint1/sensors/src/main/kotlin/thermometer/ThermometerMockMQTT.ipynb" target = "_blank">Thermometer</a>
  and <a href ="https://github.com/enriLoniterp/iss2021project/blob/main/Sprint1/sensors/src/main/kotlin/weightsensor/WeightSensorMockMQTT.ipynb" target = "_blank">weightsensor</a> can be used by opening and running them with jupyter.
  <br>
  Regarding to the <ks>outsonar</ks>, it has been deployed using <em>gradle distZip</em> command. The result of the deployment is a zip file <a href="https://github.com/enriLoniterp/iss2021project/blob/main/Sprint1/outsonar/distributions/it.unibo.rasp2021-1.0.zip" target = "_blank"><em>outsonar.zip</em></a>
  that contains a bin directory with the executables. By default the system uses a real sonar and in that case <a href="https://github.com/enriLoniterp/iss2021project/blob/main/Sprint1/outsonar/SonarAlone" target = "_blank">sonarAlone.c</a> needs to be compiled.
  Alternatevely, by changing configuration file <a href="https://github.com/enriLoniterp/iss2021project/blob/main/Sprint1/outsonar/sonar2021ConfigKb.pl" target = "_blank">sonar2021ConfigKb.pl</a> a virtual sonar can be used.
  In addicition, the broker that receives events emitted by the sonar can be choose by editing <a href="https://github.com/enriLoniterp/iss2021project/blob/main/Sprint1/outsonar/sonaronrasp.pl" target = "_blank">sonaronrasp.pl</a>.<br>
  To run the system on:
  <ul>
    <li><b>Windows</b>: open a Command Prompt, set working directory to <em>bin</em>, run <em>outsonar.bat</em>;
    <li><b>Unix</b>: open a Bash Shell, set working directory to <em>bin</em>, run <em>bash outsonar</em>;
    <li><b>MacOS</b>: open a Terminal, set working directory to <em>bin</em>, run <em>basicdevices</em>;
</div>

<h2>Job task</h2>
<table cellpadding="5%">
  <tr>
    <th>Member</th>
    <th>Task done</th>
  </tr>
  <tr>
    <td><center><b>Andrini Enrico</b><br>enrico.andrini2@studio.unibo.it</center></td>
    <td>
      <ul>
        <li>Weighsensor</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td><center><b>Cristaudo Giuseppe</b><br>giuseppe.cristaudo@studio.unibo.it</center></td>
    <td>
      <ul>
        <li>Thermometer</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td><center><b>Manfreda Filippo</b><br>filippo.manfreda@studio.unibo.it</center></td>
    <td>
      <ul>
        <li>Outsonar</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td><center><b>Team</b></center></td>
    <td>
      <ul>
        <li>Problem analysis;</li>
        <li>Testing;</li>
        <li>Deployment</li>
      </ul>
    </td>
  </tr>
</table>
<h2>Sprint Review</h2>
<div class="remark">
During the discussion with the customer we faced the possibilty to use the observer pattern as a logic interaction instead of
the publish-subscribe we used. As analyst we think they are both good at satisfying our interction requirements with sensor. However,
we think publish-subscribe interaction suits best our needs because, as we said in <a href="http://htmlpreview.github.io/?https://github.com/enriLoniterp/iss2021project/blob/main/requirements/userDocs/Automated%20Car-Parking.html" target = "_blank">our first analiys</a>,
sensors doens't know who is going to use them, this specification is fully satisfied thanks to the presence of an intermediary: the broker. This means that the publisher (sensor) and subscriber 
(adapter) are just loosely-coupled. Although the observer pattern allows you to not know a priori who the observers will be, they will be subsequently 
disclosed to the sensors directly after the registration.
A closer look at this comparison can be found <a href="https://towardsai.net/p/systems/observer-pattern-vs-pub-sub-pattern" target = "_blank">here</a>.<br/>
Regarding the broker, even if now we rely on the remote broker hivemq, it will later be replaced by a local broker (<b>Mosquitto<b/>).

</div>
<h2>Maintenance</h2>

<!-- USEFUL
<table style="width:100%" border="1">
<tr>
<td style="width:50%">
</td>
<td></td>
</tr>
</table>
-->

<br/><br/>
</div>

<div style="background-color:rgba(86, 56, 253, 0.9); width:60%;text-align:left;color:white">
By studentName email: giuseppe.cristaudo@studio.unibo.it, filippo.manfreda@studio.unibo.it, enrico.andrini2@studio.unibo.it
<!--<img src="./img/emiglio.png" alt="mbot" width="15%" height="15%">-->
</div>
</body>
</html>
